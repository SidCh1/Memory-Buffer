"""Monte Carlo simulation of a repeater chain with nondeterministic swapping and memory buffer in the doubling scheme.

The script performs a number of simulation runs, each of which corresponds
to the distribution of a single entangled pair of qubits between the end nodes
of the repeater chain. For each run, it prints the waiting time. The parameters of the simulation can be
changed at the bottom of this file.

Date: 16 Dec 2022
Author: Lina



Code explanation
================

The architecture
----------------

The repeater chain looks like this:

1  2 3  4 5  6 7  8
+  + +  + +  + +  +  step 0
+--+ +--+ +--+ +--+  step 1
+-------+ +-------+  step 2
+-----------------+  step 3

where each '+' is a node/ memory and '--' is a link. Initially, we are in step 0 with no existing links. With a fixed generation probability, we generate a link. Once we have two links prepared, we can swap to get a longer link. Swapping happens with a fixed swapping probability. Swapping is only allowed at nodes (2,3) and (6,7) in step 1 or at node (4,5) in step 2. (Doubling scheme.) 
Some nodes have a memory buffer, so that new links of step 1 can get prepared, while the link in step 2 is waiting for the second link




The protocol
------------

The protocol that this script currently implements is as follows:
In each timestep, 
- over each connection in step 0 which has free memories, elementary-link generation is attempted
- as soon as two links are prepared, swapping is attempted. Note, that swapping is only allowed between some links, see picture above.

As soon as there is a single elementary link between the end nodes, the simulation stops and output the number of timesteps.


Ideas for later
---------------
- add cutoff time
- add fidelity
"""

import numpy as np


################################################################
# CLASSES FOR A MEMORY; ELEMENATRY_LINK, LONG_LINK;            #
# - an elementary link gets generated with a fixed probability #
# - a long link gets generated by swapping                     #
################################################################



class Memory:
    """Class modelling an memory.
    Intended usage: the memory has a certain buffer space. 
    It keeps track of how many memories are occupied.
    'occupy_memory' and 'free_memory' occupies or frees memory space.
    In case we try to occupy more memory space than available 
    or we try to free an empty memory, it outputs an error message.
    'evaluate_full' checks, whether the memory buffer is full, 
    i.e. there is no free memory space left, 
    what means that we can't generate more links


    Parameters
    ----------
    buffer_space: int
        The number of available memory space, occupied or not.
    occupied_buffer_space: int
        The number of occupied buffer space,
        can't be greater than buffer_space.
    full_status: bool
        States whether the memory buffer is full or not.
    """

    def __init__(self,
                 buffer_space=1,
                 occupied_buffer_space=0,
                 full_status=False):
        self.buffer_space = buffer_space
        self.occupied_buffer_space = occupied_buffer_space
        self.full_status = full_status


    def occupy_memory(self):
        """occupies memory space"""
        if self.full_status:
            print("Something went wrong: tried to occupy more space than possible")
        else:
            self.occupied_buffer_space += 1
        self.evaluate_full()

    def free_memory(self):
        """frees memory space"""
        if self.occupied_buffer_space == 0:
            print("Something went wrong: tried to free memory space although it was free before")
        else:
            self.occupied_buffer_space -= 1
        self.evaluate_full()

    def evaluate_full(self):
        """checks, whether the memory buffer is full"""
        if self.occupied_buffer_space == self.buffer_space:
            self.full_status=True
        else:
            self.full_status=False



class Elementary_Link:
    """Class modelling an elementary link.
    Intended usage: an elementary link can exist or not.
    It needs two memories to get stored.
    If there is a free memory at each end, it attempts to get generated.
    Generation happens with a fixed generation probability.
    Ones it gets generated, it occupies memories on both sides.
    #include later: cutoff time


    Parameters
    ----------
    generation_probability: float
        Probability to generate a link.
    is_working: bool
        States whether the link is generated or not
    memoryL, memoryR: Memory
        Memories on both sides of the link
    ready_for_generation: bool
        States whether there is free memory space 
        such that a link can get generated.
    """

    def __init__(self,
                 memoryL,
                 memoryR,
                 generation_probability=1,
                 ready_for_generation=False,
                 is_working=False):
        self.generation_probability = generation_probability
        self.memoryL = memoryL
        self.memoryR = memoryR
        self.ready_for_generation = ready_for_generation
        self.is_working = is_working


    def check_buffer_space(self):
        """checks whether there is enough memory buffer to generate a link"""
        #print(self.memoryL.full_status, self.memoryR.full_status)
        if not self.memoryL.full_status and not self.memoryR.full_status:
            self.ready_for_generation = True
        else: 
            self.ready_for_generation = False

    def generation_attempt(self):
        """attempts to generate an entangled link"""
        self.check_buffer_space()
        if self.ready_for_generation:
            if np.random.random() < self.generation_probability:
                #print("link generated")
                self.turn_on()


    def turn_on(self):
        """notice, that link is working and occupy memory space"""
        self.is_working = True
        self.memoryL.occupy_memory()
        self.memoryR.occupy_memory()


    def turn_off(self):
        """turns off existing"""
        if self.is_working:
            self.is_working = False
            self.memoryL.free_memory()
            self.memoryR.free_memory()
            """Note: if swapping was successfull, memories need to get occupied again."""
        else:
            print("Something went wrong, tried to turn off a non working link.")


class Long_Link:
    """Class modelling an long link generated by swapping.
    Intended usage: a long link can exist or not.
    It occupies one memory on each side.
    It can get generated by entanglement swapping if specific shorter links are working.
    Swapping happens with a fixed swapping probability.
    #include later: cutoff time


    Parameters
    ----------
    swapping_probability: float
        Probability to swap two links.
    is_working: bool
        States whether the link is working or not
    link1, link2: Elementary_Link or Long_Link
    memoryL, memoryR: Memory
        Memories on both sides of the link
    ready_for_swapping: bool
        States whether the shorter links are generated 
        such that they can get swapped.
    """

    def __init__(self,
                 link1,
                 link2,
                 swapping_probability=1,
                 ready_for_swapping=False,
                 is_working=False):
        self.swapping_probability = swapping_probability
        self.link1 = link1
        self.link2 = link2
        self.memoryL = self.link1.memoryL
        self.memoryR = self.link2.memoryR
        self.ready_for_swapping = ready_for_swapping
        self.is_working = is_working

            
    def check_swapping_conditions(self):
        """checks whether the underlying links exist"""
        print(self.link1.is_working, self.link2.is_working)
        if self.link1.is_working and self.link2.is_working:
            self.ready_for_swapping = True
        else: 
            self.ready_for_swapping = False  



    def swapping_attempt(self):
        """attempts to swap two entangled links"""
        self.check_swapping_conditions()
        if self.ready_for_swapping:
            self.link1.turn_off()
            self.link2.turn_off()
            if np.random.random() < self.swapping_probability:
                print("swapping successful")
                self.turn_on()    

    def turn_on(self):
        """notice, that link is working and occupy memory space"""
        self.is_working = True
        self.memoryL.occupy_memory()
        self.memoryR.occupy_memory()  


    def turn_off(self):
        """turns off existing link"""
        if self.is_working:
            self.is_working = False
            self.memoryL.free_memory()
            self.memoryR.free_memory()
            """Note: if swapping was successfull, memories need to get occupied again."""
        else:
            print("Something went wrong, tried to turn off a non working link.")

